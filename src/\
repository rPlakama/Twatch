use std::fs;
use std::io::{self, Write};
use std::thread;
use std::time::{Duration, Instant};

fn countdown() {
    println!("Enter Duration(S):  ");
    let mut _i = 0u64;

    let mut input_duration = String::new();
    io::stdin().read_line(&mut input_duration).expect("Failed");
    let seconds: u64 = input_duration.trim().parse().expect(".");

    let duration = Duration::from_secs(seconds);
    let start = Instant::now();

    while Instant::now() - start <= duration {
        let elapse = Instant::now() - start;
        let remaining = duration
            .checked_sub(elapse)
            .unwrap_or_else(|| Duration::from_secs(0));
        print!("\rTime to end: {}s ", remaining.as_secs());
        std::io::stdout().flush().unwrap();
        thread::sleep(Duration::from_millis(100));
        println!("\nCountdown finished!");
    }
}
fn search_loop(duration: Duration) {
    let start = Instant::now();

    search();

    while Instant::now() - start <= duration {
        thread::sleep(Duration::from_secs(2));
        if Instant::now() - start > duration {
            break;
        }

        search();
    }
}
fn search() {
    struct Labels {
        label: String,
        is_cpu: bool,
        is_nvme: bool,
        temp: u32,
    }

    let mut search_labels: Vec<Labels> = Vec::new();

    let hwmon_paths = fs::read_dir("/sys/class/hwmon/")
        .expect("Could not read the sys/class/hwmon directory")
        .filter_map(Result::ok)
        .map(|entry| entry.path())
        .filter(|path| {
            path.is_dir()
                && path
                    .file_name()
                    .map_or(false, |name| name.to_string_lossy().starts_with("hwmon"))
        });

    for path in hwmon_paths {
        let device_name = fs::read_to_string(path.join("name"))
            .unwrap_or_default()
            .trim()
            .to_string();
        let is_nvme = device_name.contains("nvme");
        let is_cpu = device_name.contains("coretemp") || device_name.contains("k10temp");

        if let Ok(entries) = fs::read_dir(&path) {
            for entry in entries.filter_map(Result::ok) {
                let file_name = entry.file_name().to_string_lossy().to_string();
                if file_name.starts_with("temp") && file_name.ends_with("_input") {
                    let temp_string = fs::read_to_string(entry.path()).unwrap_or_default();
                    let temp_value: u32 = temp_string.trim().parse().unwrap_or(0) / 1000;
                    let label_path = entry
                        .path()
                        .with_file_name(file_name.replace("_input", "_label"));
                    let label_string = fs::read_to_string(label_path)
                        .unwrap_or("Unknown".to_string())
                        .trim()
                        .to_string();
                    search_labels.push(Labels {
                        label: label_string,
                        is_cpu: is_cpu,
                        is_nvme: is_nvme,
                        temp: temp_value,
                    });
                }
            }
        }
    }

    println!("\n");
    for label_data in &search_labels {
        let device_type = if label_data.is_cpu {
            "CPU"
        } else if label_data.is_nvme {
            "NVME"
        } else {
            "Unknown"
        };
        if device_type != "Unknown" {
            println!(
                "[{}] {}: {}°C",
                device_type, label_data.label, label_data.temp
            );
        }
    }
}
fn countdown_task(duration: Duration) {
    let start = Instant::now();

    while Instant::now() - start <= duration {
        let elapse = Instant::now() - start;
        let remaining = duration
            .checked_sub(elapse)
            .unwrap_or_else(|| Duration::from_secs(0));

        println!(
            "\x1B[H\rWatching... Time remaining: {}s ",
            remaining.as_secs()
        );
        std::io::stdout().flush().unwrap();

        thread::sleep(Duration::from_millis(100)); // pra n abusar da cpu
    }
    println!("\nWatcher finished!");
}
fn watcher() {
    println!("Watching devices temperatures, input timeout: \n");
    let mut input_duration = String::new();
    io::stdin().read_line(&mut input_duration).expect("Failed!");
    let seconds: u64 = input_duration
        .trim()
        .parse()
        .expect("Could not reach seconds");
    let duration = Duration::from_secs(seconds);

    let search_handle = thread::spawn(move || {
        search_loop(duration);
    });

    let countdown_handle = thread::spawn(move || {
        countdown_task(duration);
    });

    search_handle
        .join()
        .expect("Search: Sensors. Thread panicked.");
    countdown_handle.join().expect("Countdown thread panicked.");
}

fn main() {
    loop {
        println!("Select funtion: \n 1 ― Sensors. \n ― Sensors(With Unknown).");
        let mut input = String::new();
        io::stdin().read_line(&mut input).expect("Failed");

        let choice = input.trim();

        match choice {
            "1" => {
                println!("\x1B[2J");
                watcher();
                break;
            }
            "2" => {
                println!("\x1B[2J");
                let with_unkown: bool = true;
                watcher();
                break;
            }
            _ => {
                println!("\nThat is not a valid option. Please try again.\n");
            }
        }
    }
}
